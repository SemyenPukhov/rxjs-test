{"version":3,"sources":["components/SystemCard.jsx","utils/constants.js","utils/index.js","services/mock.service.js","services/data.service.js","components/Dashboard.jsx","App.js","serviceWorker.js","index.js"],"names":["SystemCard","system","value","key","className","randomInRange","min","max","Math","floor","random","source","interval","streamCreator","creator","pipe","concatMap","delay","temperatureStream","of","label","airPressureStream","humidityStream","sourceCreator","timeout","catchError","repeat","temperature","airPressure","humidity","dashboardSource","observable","initValue","subject","BehaviorSubject","subscribe","complete","error","x","next","convertObservableToBehaviorSubject","combineLatest","skipWhile","val","KEYS","Dashboard","useState","subscription","setSubscription","dashboardValues","setDashBoardValues","getValues","indicators","values","map","i","useEffect","unsubscribe","length","App","Boolean","window","location","hostname","match","ReactDOM","render","StrictMode","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch","console","message"],"mappings":"2RAGe,SAASA,EAAT,GAAiD,IAAD,IAA1BC,OAAUC,EAAgB,EAAhBA,MAAOC,EAAS,EAATA,IACpD,OACE,yBAAKC,UAAU,QACb,0BAAMA,UAAS,UAAKD,EAAL,UACf,0BAAMC,UAAU,aAAaD,GAC7B,0BAAMC,UAAU,aAAaF,ICR5B,I,wCCEMG,EAAgB,SAAC,GAAD,8BAAEC,OAAF,MAAQ,EAAR,SAAWC,OAAX,MAAiB,EAAjB,SAC3BC,KAAKC,MAAMD,KAAKE,UAAYH,EAAMD,EAAM,IAAMA,GCG1CK,EAASC,YAAS,IAuBlBC,EAAgB,SAAAC,GAAO,OAAI,WAC/B,OAAOH,EAAOI,KACZC,aAAU,kBACRF,IAAUC,KAAKE,YAAMZ,EAAc,CFhChB,IACA,cEqCZa,EAAoBL,GA9BN,kBACzBM,YAAG,CACDhB,IAAK,OACLiB,MAAO,cACPlB,MAAOG,EAAc,CAAC,GAAI,UA2BjBgB,EAAoBR,GAxBN,kBACzBM,YAAG,CACDhB,IAAK,MACLiB,MAAO,eACPlB,MAAOG,EAAc,CAAC,IAAK,WAqBlBiB,EAAiBT,GAlBN,kBACtBM,YAAG,CACDhB,IAAK,WACLiB,MAAO,WACPlB,MAAOG,EAAc,CAAC,GAAI,U,wCChBxBkB,EAAgB,SAAAZ,GAAM,OAC1BA,IACGI,KAAKS,YAAQ,OACbT,KAAKU,aAAW,kBAAMN,YAAG,CAAEjB,MAAO,YAClCa,KAAKW,gBAEJC,EAAcJ,EAAcL,GAC5BU,EAAcL,EAAcF,GAC5BQ,EAAWN,EAAcD,GAElBQ,EFfqC,SAACC,EAAYC,GAC7D,IAAMC,EAAU,IAAIC,IAAgBF,GAQpC,OANAD,EAAWI,UAAU,CACnBC,SAAU,kBAAMH,EAAQG,YACxBC,MAAO,SAAAC,GAAC,OAAIL,EAAQI,MAAMC,IAC1BC,KAAM,SAAAD,GAAC,OAAIL,EAAQM,KAAKD,MAGnBL,EEMsBO,CAC7BC,YAAcd,EAAaC,EAAaC,GAAUd,KAChD2B,aAAU,SAAAC,GAAG,MAAmB,qBAARA,OCjBtBC,EAAO,CAAC,cAAe,cAAe,YAE7B,SAASC,IAAa,IAAD,EACMC,mBAAS,MADf,mBAC3BC,EAD2B,KACbC,EADa,OAEYF,mBAAS,IAFrB,mBAE3BG,EAF2B,KAEVC,EAFU,KAI5BC,EAAY,SAAAC,GAChB,GAAKA,EAAL,CAGA,IAAMC,EAAST,EAAKU,KAAI,SAACnD,EAAKoD,GAC5B,MAAO,CACLrD,MAAOkD,EAAWG,GAAGrD,MACrBC,UAGJ+C,EAAmBG,KASrB,OAPAG,qBAAU,WAER,OADAR,EAAgBlB,EAAgBK,UAAUgB,IACnC,WACLJ,GAAgBA,EAAaU,iBAE9B,IAGD,oCACE,yCACA,yBAAKrD,UAAU,qBACX6C,EAAgBS,QAAU,yCAC3BT,EAAgBK,KAAI,SAACrD,EAAQsD,GAAT,OACnB,kBAACvD,EAAD,CAAYG,IAAKoD,EAAGtD,OAAQA,SCvBvB0D,MARf,WACE,OACE,yBAAKvD,UAAU,OACb,kBAACyC,EAAD,QCIce,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2DCZNC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,SDyHpB,kBAAmBC,WACrBA,UAAUC,cAAcC,MACrBC,MAAK,SAAAC,GACJA,EAAaC,gBAEdC,OAAM,SAAAvC,GACLwC,QAAQxC,MAAMA,EAAMyC,c","file":"static/js/main.5b65764b.chunk.js","sourcesContent":["import PropTypes from \"prop-types\";\nimport React from \"react\";\n\nexport default function SystemCard({ system: { value, key } }) {\n  return (\n    <div className=\"card\">\n      <span className={`${key}Icon`} />\n      <span className=\"cardTitle\">{key}</span>\n      <span className=\"cardValue\">{value}</span>\n    </div>\n  );\n}\n\nSystemCard.propTypes = {\n  system: PropTypes.shape({\n    key: PropTypes.string.isRequired,\n    value: PropTypes.oneOfType([PropTypes.string, PropTypes.number])\n  })\n};\n","export const MIN_DELAY = 100;\nexport const MAX_DELAY = 2000;\n","import { BehaviorSubject } from \"rxjs\";\n\nexport const randomInRange = ([min = 0, max = 1]) =>\n  Math.floor(Math.random() * (max - min + 1)) + min;\n\nexport const convertObservableToBehaviorSubject = (observable, initValue) => {\n  const subject = new BehaviorSubject(initValue);\n\n  observable.subscribe({\n    complete: () => subject.complete(),\n    error: x => subject.error(x),\n    next: x => subject.next(x)\n  });\n\n  return subject;\n};\n","import { MAX_DELAY, MIN_DELAY } from \"../utils/constants\";\nimport { concatMap, delay } from \"rxjs/operators\";\nimport { interval, of } from \"rxjs\";\n\nimport { randomInRange } from \"../utils\";\n\nconst source = interval(50);\n\nconst temperatureCreator = () =>\n  of({\n    key: \"temp\",\n    label: \"Temperature\",\n    value: randomInRange([18, 25])\n  });\n\nconst airPressureCreator = () =>\n  of({\n    key: \"air\",\n    label: \"Air pressure\",\n    value: randomInRange([700, 800])\n  });\n\nconst humidityCreator = () =>\n  of({\n    key: \"humidity\",\n    label: \"Humidity\",\n    value: randomInRange([30, 60])\n  });\n\nconst streamCreator = creator => () => {\n  return source.pipe(\n    concatMap(() =>\n      creator().pipe(delay(randomInRange([MIN_DELAY, MAX_DELAY])))\n    )\n  );\n};\n\n//mocks of data streams which emits values every 100 - 2000 ms\nexport const temperatureStream = streamCreator(temperatureCreator);\nexport const airPressureStream = streamCreator(airPressureCreator);\nexport const humidityStream = streamCreator(humidityCreator);\n","import {\n  airPressureStream,\n  humidityStream,\n  temperatureStream\n} from \"./mock.service\";\nimport { catchError, repeat, skipWhile, timeout } from \"rxjs/operators\";\nimport { combineLatest, of } from \"rxjs\";\n\nimport { convertObservableToBehaviorSubject } from \"../utils\";\n\nconst sourceCreator = source =>\n  source()\n    .pipe(timeout(1050))\n    .pipe(catchError(() => of({ value: \"N/A\" })))\n    .pipe(repeat());\n\nconst temperature = sourceCreator(temperatureStream);\nconst airPressure = sourceCreator(airPressureStream);\nconst humidity = sourceCreator(humidityStream);\n\nexport const dashboardSource = convertObservableToBehaviorSubject(\n  combineLatest(temperature, airPressure, humidity).pipe(\n    skipWhile(val => typeof val === \"undefined\")\n  )\n);\n","import React, { useEffect, useState } from \"react\";\n\nimport SystemCard from \"./SystemCard\";\nimport { dashboardSource } from \"../services/data.service\";\n\nconst KEYS = [\"temperature\", \"airPressure\", \"humidity\"];\n\nexport default function Dashboard() {\n  const [subscription, setSubscription] = useState(null);\n  const [dashboardValues, setDashBoardValues] = useState([]);\n\n  const getValues = indicators => {\n    if (!indicators) {\n      return;\n    }\n    const values = KEYS.map((key, i) => {\n      return {\n        value: indicators[i].value,\n        key\n      };\n    });\n    setDashBoardValues(values);\n  };\n  useEffect(() => {\n    setSubscription(dashboardSource.subscribe(getValues));\n    return () => {\n      subscription && subscription.unsubscribe();\n    };\n  }, []);\n\n  return (\n    <>\n      <h1>Dashboard</h1>\n      <div className=\"dashboardContent\">\n        {!dashboardValues.length && <p>Loading...</p>}\n        {dashboardValues.map((system, i) => (\n          <SystemCard key={i} system={system} />\n        ))}\n      </div>\n    </>\n  );\n}\n","import \"./App.css\";\n\nimport Dashboard from \"./components/Dashboard\";\nimport React from \"react\";\n\nfunction App() {\n  return (\n    <div className=\"App\">\n      <Dashboard />\n    </div>\n  );\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}